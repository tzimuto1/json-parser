High Level API
==============

json_tree = parser(<string>)

SUBSET OF JSON TO USE:
======================
- strings should be alphanumerals
- numbers should only be integers

GRAMMAR
=======
json := object | array

object = {} | { members }
members = pair | (pair , members)
pair = string : value

array = [] | [ elements ]
elements = value | value , elements
value = string | number | object | array | true | false | null

string
int (replace number with int)

json := object | array


SIMPLIFIED
object = {} | { pairs (, pair)* }
pair = string : value

array = [] | [ value (, value) ]
value = string | number | object | array | true | false | null

string = "(a|b|...)*"
int = (0|1|2...)+

ABSTRACT

API
===

value json_object.get(<string>)
value json_array.get(<index>)

json_array.iterator.get_next()

json.to_string()

- currently the created json tree should not be mutable. Only reads are possible

TYPES
=====
json:
    int   type;
    int   num;
    char *key;
    union value {
        json *members;
        json *elements;
        int   int_val; // true, false
        char *string_value;
    }


object:
    members->pair....

pair:
    string
    value

array:
    elements->value...

value = string | number | object | array | true | false | null

// seems like this is the base jype
value:
    type [string|number etc.]
    void *val


str
int
string
pair

json_object is made from pairs

CURRENTLY the json_object pairs are a linked list. Maybe do some hashing latter on

LOW LEVEL DETAILS
=================

- accessor function to peek or consume a character from the json_string


API METHODS
===========



CRUD

BASIC_API
=========
[DONE]json_create()
json_stringify()

JSON Object API
---------------
C
[^]json_create()

R
[DONE]json_object_has_key()
[DONE]json_object_has_number()
[DONE]json_object_has_boolean()
[DONE]json_object_has_string()

json_object_get()
json_object_get_all()
<notnow>
    json_object_get_number()
    json_object_get_numbers()
    json_object_get_bool()
    json_object_get_bools()
    json_object_get_string()
    json_object_get_strings()
    json_object_get_number_keys()
    json_object_get_bool_keys()
    json_object_get_string_keys()
</notnow>
json_get_size()
json_object_get_all_keys()
json_object_is_empty()
Object iterator
// TODO support of deep/nested keys/values?

U
[DONE]json_object_put_number()
[DONE]json_object_put_bool()
[DONE]json_object_put_string()
json_object_remove_member()

D
[^]json_destroy()

JSON Array API
--------------
C
json_create()

R
json_array_has_number()
json_array_has_string()
json_array_get()
<notnow>
json_array_get_number()
json_array_get_numbers()
json_array_get_bool()
json_array_get_bools()
json_array_get_string()
json_array_get_strings()
</notnow>
json_array_index_of_number()
json_array_index_of_string()
json_array_stringify() / json_value_stringify()
json_array_is_empty()

U
json_array_set_value_at()
json_array_set_remove_element_at()

D
json_destroy()






/*
 * Get the number corresponding to given key
 */
double *json_object_get_number(json *object, const char *key)
{
    int   i = 0;

    if (!JSON_HAS_TYPE(object, JSON_TYPE_OBJECT))
        return NULL;

    for (i = 0; i < object->cnt; i++)
    {
        if (strcmp(key, object->members[i]->key) == 0)
            return object->members[i]->value;
    }

    return NULL;
}


